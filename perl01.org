#+TITLE: Perl01
#+EXCLUDE_TAGS: noexport

* Inhalt :toc:noexport:
- [[#hallo-welt][Hallo Welt]]
- [[#ausgabe][Ausgabe]]
  - [[#ausgabe-von-zahlen][Ausgabe von Zahlen]]
  - [[#ausgabe-von-strings][Ausgabe von Strings]]
- [[#operatoren][Operatoren]]
  - [[#bit-operatoren][Bit-Operatoren]]
  - [[#vergleichsoperatoren][Vergleichsoperatoren]]
  - [[#boolsche-operatoren][Bool'sche Operatoren]]
  - [[#string-operatoren][String-Operatoren]]
- [[#variablen][Variablen]]
  - [[#scalar][Scalar]]
- [[#referenzen][Referenzen]]

* Hallo Welt
Aufbau ähnlich zu =bash= und =C=. Definition von Interpreter und Import von Packeten.
Flag "-w", um zusätzliche Interpreter-Warnungen mit anzuzeigen.
*Wichtig*: ";" am Zeilenende.

#+begin_src perl :results output :exports both
#!/usr/bin/perl -w
use strict;
use warnings;

print "Hallo Welt!\n";
#+end_src

#+RESULTS:
: Hallo Welt!

* Ausgabe
** Ausgabe von Zahlen
Perl interpretiert die Ausgabe von Zahlen generell als Dezimalzahl (=Integer=). Möchte man stattdessen binär oder hexadezimal, muss ein entsprechendes "Kontrollzeichen" davor stehen. Bei binär ist es eine =führende 0=, bei hexadezimal ein =führendes 0x=. Lange Zahlen können zur besseren Lesbarkeit durch "_" aufgeteilt werden.

#+begin_src perl :results output :exports both
#!/usr/bin/perl
use strict;
use warnings;

print "Octal: ", 01111;
print "\n";
print "Binär: ", 0b1111;
print "\n";
print "Hex: ", 0xAF;
print "\n";
print "Deizomal: ", 1111;
print "\n";
print "Lange Zahl: ", 123_456_789;
print "\n";
print "Float: ", 3.141592654;
#+end_src

#+RESULTS:
: Octal: 585
: Binär: 15
: Hex: 175
: Deizomal: 1111
: Lange Zahl: 123456789
: Float: 3.141592654

** Ausgabe von Strings
Perl unterscheidet bei Strings in einfache und doppelte Anführungszeichen. Der Unterschied ist, wie bei =bash= auch, die Interpretierung von Steuerzeichen, wie "\t". Diese können aber durch ein "\" gecancelt werden. Es können auch verschiedene Zeichen kombiniert werden, sodass auch eine Ausgabe von Zitaten möglich wird. Eine weitere Alternative sind die sog. *quote-like operators*. Diese definieren ein umschließende Begrenzer des Textes und vereinfachen so die Lesbarkeit.
#+begin_src perl :results output :exports both
#!/usr/bin/perl
use strict;
use warnings;

print 'Hallo\t Welt';
print "\n";
print "Hallo\t Welt";
print "\n";
print "Hallo\\t Welt";
print "\n";
print '"Halt, STOP!"';
print "\n";
print qq<'"Hallo Welt" wird oft als erstes Programm geschrieben'>;
print "\n";
print qq|'"Hallo Welt" wird oft als erstes Programm geschrieben'|;
print "\n";
print qq('"Hallo Welt" wird oft als erstes Programm geschrieben');
print "\n";
#+end_src

#+RESULTS:
: Hallo\t Welt
: Hallo	 Welt
: Hallo\t Welt
: "Halt, STOP!"
: '"Hallo Welt" wird oft als erstes Programm geschrieben'
: '"Hallo Welt" wird oft als erstes Programm geschrieben'
: '"Hallo Welt" wird oft als erstes Programm geschrieben'

* Operatoren
** Bit-Operatoren

#+begin_src perl :results output :exports both
#!/usr/bin/perl
use strict;
use warnings;

print "8 AND 4: ", 8&4, "\n";
print "8 OR 4: ", 8|4, "\n";
print "8 XOR 4: ", 8^4, "\n";
print "NOT 4: ", ~4, "\n";
#+end_src

#+RESULTS:
: 8 AND 4: 0
: 8 OR 4: 12
: 8 XOR 4: 12
: NOT 4: 18446744073709551611

** Vergleichsoperatoren

#+begin_src perl :results output :exports both
#!/usr/bin/perl
use strict;
use warnings;

print "8 == 4: ", 8==4, "\n";
print "8 > 4: ", 8>4, "\n";
print "8 < 4: ", 8<4, "\n";
print "8 != 4: ", 8!=4, "\n";
print "8 >= 4: ", 8>=4, "\n";
print "8 <= 4: ", 8<=4, "\n";
# folgender Operator ergibt: 0, falls gleich; -1, falls 4>8 und +1, falls 8>4
print "8 <=> 4: ", 8<=>4, "\n";

#+end_src

#+RESULTS:
: 8 == 4:
: 8 > 4: 1
: 8 < 4:
: 8 != 4: 1
: 8 >= 4: 1
: 8 <= 4:
: 8 <=> 4: 1

** Bool'sche Operatoren
Obacht bei ausgeschriebene Operatoren "and" und "or", hier wendet Perl eine "lazy evaluation" an und stoppt, sobald eine zutreffende Aussage erkannt wid. Daher wird u.a. der Zeilenumbruch der 2. Codezeile nicht dargestellt.
#+begin_src perl :results output :exports both
#!/usr/bin/perl
use strict;
use warnings;

print "6>3 AND 3>4: ", 6>3 && 3>4, "\n";
print "6>3 AND 3>4: ", 6>3 and 3>4, "\n";
print "6>3 OR 3>4: ", 6>3 || 3>4, "\n";
print "6>3 OR 3>4: ", 6>3 or 3>4, "\n";
print "!(2>3): ", !(2>3), "\n";
print "!2>3: ", !2>3, "\n";
#+END_SRC

#+RESULTS:
: 6>3 AND 3>4:
: 6>3 AND 3>4: 16>3 OR 3>4: 1
: 6>3 OR 3>4: 1!(2>3): 1
: !2>3:

** String-Operatoren
*** Stings kombinieren
Bei Strings spielt es keine Rolle, ob man Sätze als Zusammenschluss mehrerer Wörter oder mittels des =concatenation operator= zusammensetzt. Letzteres geht etwas schneller. Ebenso werden Rechenoperationen zuerst ausgeführt und dann mit dem restlichen Text zusammengebastelt. Auch das mehrmalige Aneinanderhängen ist möglich.
#+begin_src perl :results output :exports both
#!/usr/bin/perl
use strict;
use warnings;

print "Print ", "several ", "strings ", "here.","\n";
print "Print " . "several " . "strings " . "here." . "\n";
print "Sieben mal Sieben ergibt " . 7*7 . "\n";
print "Ha! "x3, "\n";
print "na"x(2*4) . " Batmaaaan!", "\n";
#+END_SRC

#+RESULTS:
: Print several strings here.
: Print several strings here.
: Sieben mal Sieben ergibt 49
: Ha! Ha! Ha!
: nananananananana Batman!

*** Strings vergleichen
Auch ein Vergleich von Strings ist möglich. Hier wird die Zeichenkette zeichenweise verglichen. Voraussetzung ist allerdings, dass er Operator *ausgeschrieben* wird.
#+begin_src perl :results output :exports both
#!/usr/bin/perl
use strict;
use warnings;

print"Which came first, the chicken or the egg? ";
print "chicken" cmp "egg", "\n";
print "Are dogs greater than cats? ";
print "dog" gt "cat", "\n";
print "Is ^ less than + ? ";
print "^" lt "+", "\n";
#+END_SRC

#+RESULTS:
: Which came first, the chicken or the egg? -1
: Are dogs greater than cats? 1
: Is ^ less than + ?

Wendet man hingegen "gewöhnliche" Binäroperatoren an, wird der String zuerst in eine Zahl umgewandelt und dann verglichen. Da beide nicht mit einer Ziffer beginnen, werden beide gleichermaßen als "0" interpretiert. Die Umwandlung kann man selbst als Summe aus String und "0" nachvollziehen.
#+begin_src perl :results output :exports both
#!/usr/bin/perl
use strict;
use warnings;

print "'six' als Zahl: ", "six" + 0, "\n";
print "'four als Zahl: ", "four" + 0, "\n";
print "'sixand4' als Zahl: ", "sixand4" + 0, "\n";
print "'4andsix' als Zahl: ", "4andsix" + 0, "\n";

print "Test one: ", "four" eq "six", "\n";
print "Test two: ", "four" == "six", "\n";
#+END_SRC

#+RESULTS:
: 'six' als Zahl: 0
: 'four als Zahl: 0
: 'sixand4' als Zahl: 0
: '4andsix' als Zahl: 4
: Test one:
: Test two: 1


* Variablen
** Scalar
*** String
Scalar Variablen beginnen mit einem "$"-Zeichen. Man kann ihnen beliebige Datentypen zuweisen, deren Länge nur durch den Arbeitsspeicher begrenzt sind. Ihnen können im Verlauf des Programmes auch andere Werte zugewiesen werden ohne sie wieder neu initialisieren zu müssen.
#+begin_src perl :results output :exports both
#!/usr/bin/perl
use strict;
use warnings;

my $name = "Bob";
print "My name is ", $name, "\n";
$name = "Alice";
print "My name is ", $name, "\n";
#+END_SRC

#+RESULTS:
: My name is Bob
: My name is Alice


*** Integer
Variablen können auch Integer Werte zugewiesen werden; z.B. direkt aus einer Berechnung heraus.

#+begin_src perl :results output :exports both
#!/usr/bin/perl
use strict;
use warnings;

$a = 2*3;
print "2 mal 3 macht: ", $a, "\n";
$a += 3;
print "und 3 macht: ", $a, "\n";
$b = $a*2;
print "mal 2 macht: ", $b, "\n";
#+END_SRC

#+RESULTS:
: 2 mal 3 macht: 6
: und 3 macht: 9
: mal 2 macht: 18

* Referenzen
Buch "Beginning Perl": https://learn.perl.org/books/beginning-perl/
